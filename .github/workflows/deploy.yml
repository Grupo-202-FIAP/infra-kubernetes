name: Deploy na AWS (Terraform & Kubernetes)

on:
  workflow_dispatch:
    inputs:
      image:
        description: "Imagem da aplicação (incluindo tag) para deploy"
        required: true
        type: string
        default: ghcr.io/Grupo-202-FIAP/api:latest
      deployment:
        description: "Deployment Kubernetes a atualizar"
        required: true
        default: "fastfood-app"
      container:
        description: "Container (nome do container dentro do pod)"
        required: true
        default: "fastfood-api"
      namespace:
        description: "Namespace Kubernetes"
        required: true
        default: "default"

jobs:
  terraform:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Código
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Debug - Verificar se Secrets não estão vazios
        run: |
          echo "Access Key ID está presente: ${{ secrets.AWS_ACCESS_KEY_ID != '' }}"
          echo "Secret Access Key está presente: ${{ secrets.AWS_SECRET_ACCESS_KEY != '' }}"
          echo "Session Token está presente: ${{ secrets.AWS_SESSION_TOKEN != '' }}"
          echo "Region está presente: ${{ secrets.AWS_REGION != '' }}"

      - name: Configurar Credenciais AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Terraform Init
        run: terraform init
        working-directory: ./infra/terraform

      - name: Format Terraform
        run: terraform fmt -check -recursive
        working-directory: ./infra/terraform

      - name: Validate Terraform
        run: terraform validate
        working-directory: ./infra/terraform

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        working-directory: ./infra/terraform

#      - name: Terraform Apply
#        if: github.ref == 'refs/heads/main'
#        run: terraform apply -auto-approve tfplan
#        working-directory: ./infra/terraform

  deploy:
    runs-on: ubuntu-latest
    needs: terraform
    steps:
      - name: Checkout Infra Repo
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Instalar kubectl e Configurar Acesso ao EKS
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name nexTime-cluster

      - name: Instalar Secrets Store CSI Driver
        run: |
          echo "Instalando CSI Driver (Secrets Store) e AWS Provider"
          
          kubectl apply -f https://github.com/kubernetes-sigs/secrets-store-csi-driver/releases/download/v1.5.4/secrets-store-csi-driver.yaml
          kubectl apply -f https://github.com/aws/secrets-store-csi-driver-provider-aws/releases/download/v2.1.1/secrets-store-csi-driver-provider-aws.yaml
          
          echo "Aguardando o registro do Custom Resource Definition (CRD)..."
          kubectl wait --for condition=established crd/secretproviderclasses.secrets-store.csi.x-k8s.io --timeout=90s
          
          echo "Instalação do CSI Driver concluída."

      - name: Aplicar Manifestos Kubernetes
        run: |
          echo "Aplicando todos os manifestos em infra/k8s..."
          kubectl apply -R -f ./infra/k8s/

      - name: Deploy no Kubernetes
        env:
          K8S_IMAGE: ${{ github.event.inputs.image }}
          K8S_DEPLOYMENT: ${{ github.event.inputs.deployment }}
          K8S_CONTAINER: ${{ github.event.inputs.container }}
          K8S_NAMESPACE: ${{ github.event.inputs.namespace }}
        run: |
          echo "Deploying image $K8S_IMAGE to deployment $K8S_DEPLOYMENT in namespace $K8S_NAMESPACE"
          
          kubectl get deployment $K8S_DEPLOYMENT -n $K8S_NAMESPACE || { 
            echo "Erro: Deployment $K8S_DEPLOYMENT não encontrado no namespace $K8S_NAMESPACE."
            exit 1 
          }
          
          kubectl set image deployment/$K8S_DEPLOYMENT \
            $K8S_CONTAINER=$K8S_IMAGE \
            -n $K8S_NAMESPACE --record
          
          echo "Aguardando o rollout do deployment..."
          kubectl rollout status deployment/$K8S_DEPLOYMENT \
            -n $K8S_NAMESPACE --timeout=120s 
          
          if [ $? -ne 0 ]; then
            echo "Rollout falhou. Iniciando Rollback..."
            kubectl rollout undo deployment/$K8S_DEPLOYMENT -n $K8S_NAMESPACE
            exit 1
          else
            echo "Rollout concluído com sucesso!"
          fi
